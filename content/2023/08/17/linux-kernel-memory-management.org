#+OPTIONS: author:nil ^:{}
#+HUGO_BASE_DIR: ../../../..
#+HUGO_SECTION: post/2023/08
#+HUGO_CUSTOM_FRONT_MATTER: :toc true
#+HUGO_AUTO_SET_LASTMOD: t
#+HUGO_DRAFT: false
#+DATE: [2023-08-17 Thu 13:19]
#+TITLE: Linux内存管理
#+HUGO_TAGS: Kernel, OS
#+HUGO_CATEGORIES: Kernel
#+STARTUP: inlineimages

* 引子(废话

=Linux kernel= 的作用之一是管理计算机的硬件资源,其中一个硬件资源就是内存, =Linux kernel= 中管理内存的一部分被称为内存管理子系统.

从大的方面来说,内存管理子系统需要管理物理内存和虚拟内存两部分.物理内存是真实存在的,虚拟内存只存在于逻辑上,我们平时所说的虚拟内存空间就是指虚拟内存在逻辑上的布局,例如,虚拟内存的第一个内存单元到第100个内存单元的状态(也就是说这些内存单元存储了什么内容).对于应用程序员来说,只需要了解虚拟内存空间的知识就够了.Linux内存管理的作用就是对应用程序员隐藏比较复杂的底层内存管理逻辑,提供给他们一个易于操作的虚拟内存空间.

本文的目的是探索Linux内存管理子系统的工作方式,中间会涉及到具体的代码.理想情况下,本文会涉及内存管理子系统从Linux加电启动到普通程序运行的方方面面,所以这个战线会很长,本文也会持续很长时间才会完结(希望能顺利完结.

* 概述

如上所述,内存管理子系统需要管理物理内存资源和虚拟内存资源.

在 =Linux kernel v5.10= 中,物理内存管理包含了 =memblock= 和 =buddy system= 两大机制(另外还有基于 =buddy system= 的小块内存管理技术),虚拟内存管理分为用户空间内存管理和内核空间内存管理,用户空间内存管理主要包含 =malloc=, =mmap=,内核空间内存管理包含了 =kmalloc= 和 =vmalloc=.除此之外, =Linux kernel= 还实现了一些内存管理的优化机制,比如按需分页, =fork= 的写时复制, =swap= 机制,这些也会被本文所涵盖.

* 物理内存管理

=memblock= 和 =buddy system= 是物理内存管理的两大手段,其中, =memblock= *主要* 用在启动阶段(在启动后的阶段, =memblock= 的一部分也会被用到,请看后文), =buddy system= 主要用在运行阶段.

本文主要从初始化,内存分配,内存回收三方面来讨论这两大机制.初始化是指获取物理内存的大小,物理地址等信息,并且使用一个数据结构来维护这些信息;内存分配和回收也都是在维护这一数据结构.一旦物理内存管理初始化完毕,内核会 *主要* 通过相关接口来获取物理内存(有可能在一些需要优化的场景不会使用这些接口).

** 初始化阶段(启动阶段)

** 运行阶段(启动后的阶段)

* 虚拟内存管理

** 内核空间

** 用户空间

