+++
title = "处理器乱序"
date = 2023-04-21T13:46:00+08:00
lastmod = 2023-04-23T15:37:59+08:00
tags = ["处理器"]
categories = ["处理器", "乱序"]
draft = false
toc = true
+++

## 备忘 {#备忘}


### 顺序流水线处理器存在哪些hazards? {#顺序流水线处理器存在哪些hazards}

以五级流水线为例.

-   写后读(RAW): 发生写后读是因为寄存器的写回操作发生在第五个流水级(WB),寄存器的读操作发生在第二个流水级(ID).假设对R寄存器的写指令之后,紧跟着对R寄存器的读指令,当执行到读指令的第二个流水级(ID)时,正执行到写指令的第三个流水级(EXE),所以此时R寄存器仍为旧值.
-   读后写(WAR)
-   写后写(WAW)

只有RAW是在 `in-order` 流水线中存在的 hazard.引入乱序以后,才会出现WAR和WAW.

详情查google.

通过阻塞或者前递技术(forwarding)可以解决RAW的问题.

因为在forwarding的实现中,也用到了阻塞技术,所以这里只说forwarding.


#### forwarding如何实现? {#forwarding如何实现}

-   forwarding以后,还需要阻塞吗?
    如果是将前一条指令执行阶段的结果forwarding到后一条指令的执行阶段,则不需要阻塞;如果是将前一条指令访存阶段的结果forwarding到后一条指令的执行阶段,则需要阻塞一拍.

-   将哪个阶段的结果forwarding到哪个阶段?
    如果前一条指令是在执行阶段就能拿到结果(计算指令在执行阶段可以拿到结果),需要将前一条指令 **执行阶段** 的结果forwarding到后一条指令的 **执行阶段**;如果前一条指令在访存阶段才能拿到结果(访存指令在访存阶段才能拿到结果),需要将后一条指令阻塞一拍,并将前一条指令 **访存阶段** 的结果forwarding到后一条指令的 **执行阶段**.

-   如何知道要用前递的数据还是从寄存器读出的数据?
    给ALU的源操作数加个多路选择器,多路选择器的一个输入是寄存器堆,另一个输入是前递来的数据.

    假设第一条指令是写R寄存器的指令i(指令i是运算指令),第二条指令是读寄存器的指令j.
    我个人的想法是,在ID时维护寄存器的"状态",在对指令i进行ID时,记录一下寄存器R正在被写,且结果在EXE阶段可以出来,这个状态我们可以用01来代表;当对指令j进行ID时,发现寄存器R的状态是01,就可以产生一个信号,告诉处理器下个EXE阶段要选择前递过来的数据.

    假设第一条指令是写R寄存器的指令i(指令i是访存指令),第二条指令是读寄存器的指令j.
    在对指令i进行ID时,记录一下寄存器R正在被写,且结果在WB阶段可以出来,这个状态我们可以用10来代表;当对指令j进行ID时,发现寄存器R的状态是10,就可以产生一个信号,告诉处理器IF,ID,EXE单元都需要阻塞一拍,且下个EXE阶段要选择前递过来的数据.

    当然,在实际开发时,要记录下每个寄存器的状态是浪费资源的,其实只用记录下每个阶段的指令会影响到哪个寄存器就好,这样,如果指令j在ID时发现处于EXE阶段的指令会影响到寄存器R,就取上一条指令EXE阶段前递过来的结果;如果指令j在ID时发现出于MEM阶段的指令会影响到寄存器R,就阻塞一拍,并取上一条指令MEM阶段前递过来的结果.
