<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>语法分析 | me</title><meta name=keywords content><meta name=description content="语法分析简介 语法分析的任务 语法分析是编译器继词法分析之后的一个重要步骤,主要任务是将输入的源代码转换为语法分析树或者抽象语法树,以便后续的语义分析,中间代码生成和优化等处理.
具体来说,语法分析的任务包括以下几个方面:
识别输入的源代码中是否存在语法错误,即判断输入的源代码是否符合给定的文法规则.如果存在语法错误,语法分析器将报告相应的错误信息. 将输入的源代码转换为语法分析树或者抽象语法树.语法分析树是一个表示源代码语法结构的树形结构,每个节点代表源代码中的一个语法成分,如语句,表达式,运算符等.抽象语法树则是一种去除冗余信息后的语法树,只保留程序的语义信息,用于后续的代码生成和优化. 为每个节点附加语义信息,如数据类型,变量名,函数名等.这些信息将在后续的语义分析和代码生成中用到. 生成错误信息和警告信息,以便提示开发者对源代码进行改正. 强大的语法分析生成器 bison bison 是 flex 的亲密战友,它是一种强大的语法分析器生成器,可以根据用户提供的上下文无关文法生成相应的语法分析器.
bison 可以通过读取用户提供的语法规则,生成相应的语法分析器,从而将源代码转换为语法分析树或者抽象语法树,并对语法错误进行报告.
同时, bison 还提供了丰富的选项和功能,如语法冲突检查,语法错误处理,语法树的生成和遍历等,方便开发者进行灵活的配置和使用.
bison 的语法规则基于类似于 BNF 的范式,可以包含终结符和非终结符,以及相应的语义动作.它使用 LALR(1) 分析算法,能够高效地处理大规模的语法规则和输入流,同时还提供了一些高级特性,如词法和语法错误处理,优先级和关联性规则,语法树生成和遍历等.
使用 bison 手册1.8节提供了使用 bison 的一般步骤. 使用 bison 生成语法分析器的基本步骤与使用 flex 非常类似,具体步骤如下:
编写语法规则文件,将要分析的程序语言语法描述出来 使用 bison 编译语法规则文件,生成C文件 编译链接这些C文件成一个二进制程序 运行二进制程序,进行语法分析 下面以分析计算器的语法为例,说明一下这四个步骤:
编写语法规则文件（通常使用扩展名为 .y 的文件）,定义计算器的语法规则.以下是一个简单的例子:
%{ #include <stdio.h> %} %token NUMBER %left '+' '-' %left '*' '/' %precedence UMINUS %% expression: NUMBER | expression '+' expression | expression '-' expression | expression '*' expression | expression '/' expression | '-' expression %prec UMINUS ; %% int main() { yyparse(); return 0; } int yyerror(char const *msg) { fprintf(stderr, &#34;Error: %s\n&#34;, msg); return 0; } int yywrap() { return 1; } 其中,%{ 和 %} 之间的代码是在解析器中使用的C代码,%token 定义了词法分析器生成的符号类型,%left 和 %precedence 定义了运算符的优先级和结合性."><meta name=author content="Me"><link rel=canonical href=http://tengwu.quest/2023/03/28/parser/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://tengwu.quest/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://tengwu.quest/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://tengwu.quest/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://tengwu.quest/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://tengwu.quest/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="语法分析"><meta property="og:description" content="语法分析简介 语法分析的任务 语法分析是编译器继词法分析之后的一个重要步骤,主要任务是将输入的源代码转换为语法分析树或者抽象语法树,以便后续的语义分析,中间代码生成和优化等处理.
具体来说,语法分析的任务包括以下几个方面:
识别输入的源代码中是否存在语法错误,即判断输入的源代码是否符合给定的文法规则.如果存在语法错误,语法分析器将报告相应的错误信息. 将输入的源代码转换为语法分析树或者抽象语法树.语法分析树是一个表示源代码语法结构的树形结构,每个节点代表源代码中的一个语法成分,如语句,表达式,运算符等.抽象语法树则是一种去除冗余信息后的语法树,只保留程序的语义信息,用于后续的代码生成和优化. 为每个节点附加语义信息,如数据类型,变量名,函数名等.这些信息将在后续的语义分析和代码生成中用到. 生成错误信息和警告信息,以便提示开发者对源代码进行改正. 强大的语法分析生成器 bison bison 是 flex 的亲密战友,它是一种强大的语法分析器生成器,可以根据用户提供的上下文无关文法生成相应的语法分析器.
bison 可以通过读取用户提供的语法规则,生成相应的语法分析器,从而将源代码转换为语法分析树或者抽象语法树,并对语法错误进行报告.
同时, bison 还提供了丰富的选项和功能,如语法冲突检查,语法错误处理,语法树的生成和遍历等,方便开发者进行灵活的配置和使用.
bison 的语法规则基于类似于 BNF 的范式,可以包含终结符和非终结符,以及相应的语义动作.它使用 LALR(1) 分析算法,能够高效地处理大规模的语法规则和输入流,同时还提供了一些高级特性,如词法和语法错误处理,优先级和关联性规则,语法树生成和遍历等.
使用 bison 手册1.8节提供了使用 bison 的一般步骤. 使用 bison 生成语法分析器的基本步骤与使用 flex 非常类似,具体步骤如下:
编写语法规则文件,将要分析的程序语言语法描述出来 使用 bison 编译语法规则文件,生成C文件 编译链接这些C文件成一个二进制程序 运行二进制程序,进行语法分析 下面以分析计算器的语法为例,说明一下这四个步骤:
编写语法规则文件（通常使用扩展名为 .y 的文件）,定义计算器的语法规则.以下是一个简单的例子:
%{ #include <stdio.h> %} %token NUMBER %left '+' '-' %left '*' '/' %precedence UMINUS %% expression: NUMBER | expression '+' expression | expression '-' expression | expression '*' expression | expression '/' expression | '-' expression %prec UMINUS ; %% int main() { yyparse(); return 0; } int yyerror(char const *msg) { fprintf(stderr, &#34;Error: %s\n&#34;, msg); return 0; } int yywrap() { return 1; } 其中,%{ 和 %} 之间的代码是在解析器中使用的C代码,%token 定义了词法分析器生成的符号类型,%left 和 %precedence 定义了运算符的优先级和结合性."><meta property="og:type" content="article"><meta property="og:url" content="http://tengwu.quest/2023/03/28/parser/"><meta property="og:image" content="http://tengwu.quest/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="2023"><meta property="article:published_time" content="2023-03-28T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-28T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://tengwu.quest/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="语法分析"><meta name=twitter:description content="语法分析简介 语法分析的任务 语法分析是编译器继词法分析之后的一个重要步骤,主要任务是将输入的源代码转换为语法分析树或者抽象语法树,以便后续的语义分析,中间代码生成和优化等处理.
具体来说,语法分析的任务包括以下几个方面:
识别输入的源代码中是否存在语法错误,即判断输入的源代码是否符合给定的文法规则.如果存在语法错误,语法分析器将报告相应的错误信息. 将输入的源代码转换为语法分析树或者抽象语法树.语法分析树是一个表示源代码语法结构的树形结构,每个节点代表源代码中的一个语法成分,如语句,表达式,运算符等.抽象语法树则是一种去除冗余信息后的语法树,只保留程序的语义信息,用于后续的代码生成和优化. 为每个节点附加语义信息,如数据类型,变量名,函数名等.这些信息将在后续的语义分析和代码生成中用到. 生成错误信息和警告信息,以便提示开发者对源代码进行改正. 强大的语法分析生成器 bison bison 是 flex 的亲密战友,它是一种强大的语法分析器生成器,可以根据用户提供的上下文无关文法生成相应的语法分析器.
bison 可以通过读取用户提供的语法规则,生成相应的语法分析器,从而将源代码转换为语法分析树或者抽象语法树,并对语法错误进行报告.
同时, bison 还提供了丰富的选项和功能,如语法冲突检查,语法错误处理,语法树的生成和遍历等,方便开发者进行灵活的配置和使用.
bison 的语法规则基于类似于 BNF 的范式,可以包含终结符和非终结符,以及相应的语义动作.它使用 LALR(1) 分析算法,能够高效地处理大规模的语法规则和输入流,同时还提供了一些高级特性,如词法和语法错误处理,优先级和关联性规则,语法树生成和遍历等.
使用 bison 手册1.8节提供了使用 bison 的一般步骤. 使用 bison 生成语法分析器的基本步骤与使用 flex 非常类似,具体步骤如下:
编写语法规则文件,将要分析的程序语言语法描述出来 使用 bison 编译语法规则文件,生成C文件 编译链接这些C文件成一个二进制程序 运行二进制程序,进行语法分析 下面以分析计算器的语法为例,说明一下这四个步骤:
编写语法规则文件（通常使用扩展名为 .y 的文件）,定义计算器的语法规则.以下是一个简单的例子:
%{ #include <stdio.h> %} %token NUMBER %left '+' '-' %left '*' '/' %precedence UMINUS %% expression: NUMBER | expression '+' expression | expression '-' expression | expression '*' expression | expression '/' expression | '-' expression %prec UMINUS ; %% int main() { yyparse(); return 0; } int yyerror(char const *msg) { fprintf(stderr, &#34;Error: %s\n&#34;, msg); return 0; } int yywrap() { return 1; } 其中,%{ 和 %} 之间的代码是在解析器中使用的C代码,%token 定义了词法分析器生成的符号类型,%left 和 %precedence 定义了运算符的优先级和结合性."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"2023s","item":"http://tengwu.quest/2023/"},{"@type":"ListItem","position":2,"name":"语法分析","item":"http://tengwu.quest/2023/03/28/parser/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"语法分析","name":"语法分析","description":"语法分析简介 语法分析的任务 语法分析是编译器继词法分析之后的一个重要步骤,主要任务是将输入的源代码转换为语法分析树或者抽象语法树,以便后续的语义分析,中间代码生成和优化等处理.\n具体来说,语法分析的任务包括以下几个方面:\n识别输入的源代码中是否存在语法错误,即判断输入的源代码是否符合给定的文法规则.如果存在语法错误,语法分析器将报告相应的错误信息. 将输入的源代码转换为语法分析树或者抽象语法树.语法分析树是一个表示源代码语法结构的树形结构,每个节点代表源代码中的一个语法成分,如语句,表达式,运算符等.抽象语法树则是一种去除冗余信息后的语法树,只保留程序的语义信息,用于后续的代码生成和优化. 为每个节点附加语义信息,如数据类型,变量名,函数名等.这些信息将在后续的语义分析和代码生成中用到. 生成错误信息和警告信息,以便提示开发者对源代码进行改正. 强大的语法分析生成器 bison bison 是 flex 的亲密战友,它是一种强大的语法分析器生成器,可以根据用户提供的上下文无关文法生成相应的语法分析器.\nbison 可以通过读取用户提供的语法规则,生成相应的语法分析器,从而将源代码转换为语法分析树或者抽象语法树,并对语法错误进行报告.\n同时, bison 还提供了丰富的选项和功能,如语法冲突检查,语法错误处理,语法树的生成和遍历等,方便开发者进行灵活的配置和使用.\nbison 的语法规则基于类似于 BNF 的范式,可以包含终结符和非终结符,以及相应的语义动作.它使用 LALR(1) 分析算法,能够高效地处理大规模的语法规则和输入流,同时还提供了一些高级特性,如词法和语法错误处理,优先级和关联性规则,语法树生成和遍历等.\n使用 bison 手册1.8节提供了使用 bison 的一般步骤. 使用 bison 生成语法分析器的基本步骤与使用 flex 非常类似,具体步骤如下:\n编写语法规则文件,将要分析的程序语言语法描述出来 使用 bison 编译语法规则文件,生成C文件 编译链接这些C文件成一个二进制程序 运行二进制程序,进行语法分析 下面以分析计算器的语法为例,说明一下这四个步骤:\n编写语法规则文件（通常使用扩展名为 .y 的文件）,定义计算器的语法规则.以下是一个简单的例子:\n%{ #include \u0026lt;stdio.h\u0026gt; %} %token NUMBER %left \u0026#39;+\u0026#39; \u0026#39;-\u0026#39; %left \u0026#39;*\u0026#39; \u0026#39;/\u0026#39; %precedence UMINUS %% expression: NUMBER | expression \u0026#39;+\u0026#39; expression | expression \u0026#39;-\u0026#39; expression | expression \u0026#39;*\u0026#39; expression | expression \u0026#39;/\u0026#39; expression | \u0026#39;-\u0026#39; expression %prec UMINUS ; %% int main() { yyparse(); return 0; } int yyerror(char const *msg) { fprintf(stderr, \u0026#34;Error: %s\\n\u0026#34;, msg); return 0; } int yywrap() { return 1; } 其中,%{ 和 %} 之间的代码是在解析器中使用的C代码,%token 定义了词法分析器生成的符号类型,%left 和 %precedence 定义了运算符的优先级和结合性.","keywords":[],"articleBody":" 语法分析简介 语法分析的任务 语法分析是编译器继词法分析之后的一个重要步骤,主要任务是将输入的源代码转换为语法分析树或者抽象语法树,以便后续的语义分析,中间代码生成和优化等处理.\n具体来说,语法分析的任务包括以下几个方面:\n识别输入的源代码中是否存在语法错误,即判断输入的源代码是否符合给定的文法规则.如果存在语法错误,语法分析器将报告相应的错误信息. 将输入的源代码转换为语法分析树或者抽象语法树.语法分析树是一个表示源代码语法结构的树形结构,每个节点代表源代码中的一个语法成分,如语句,表达式,运算符等.抽象语法树则是一种去除冗余信息后的语法树,只保留程序的语义信息,用于后续的代码生成和优化. 为每个节点附加语义信息,如数据类型,变量名,函数名等.这些信息将在后续的语义分析和代码生成中用到. 生成错误信息和警告信息,以便提示开发者对源代码进行改正. 强大的语法分析生成器 bison bison 是 flex 的亲密战友,它是一种强大的语法分析器生成器,可以根据用户提供的上下文无关文法生成相应的语法分析器.\nbison 可以通过读取用户提供的语法规则,生成相应的语法分析器,从而将源代码转换为语法分析树或者抽象语法树,并对语法错误进行报告.\n同时, bison 还提供了丰富的选项和功能,如语法冲突检查,语法错误处理,语法树的生成和遍历等,方便开发者进行灵活的配置和使用.\nbison 的语法规则基于类似于 BNF 的范式,可以包含终结符和非终结符,以及相应的语义动作.它使用 LALR(1) 分析算法,能够高效地处理大规模的语法规则和输入流,同时还提供了一些高级特性,如词法和语法错误处理,优先级和关联性规则,语法树生成和遍历等.\n使用 bison 手册1.8节提供了使用 bison 的一般步骤. 使用 bison 生成语法分析器的基本步骤与使用 flex 非常类似,具体步骤如下:\n编写语法规则文件,将要分析的程序语言语法描述出来 使用 bison 编译语法规则文件,生成C文件 编译链接这些C文件成一个二进制程序 运行二进制程序,进行语法分析 下面以分析计算器的语法为例,说明一下这四个步骤:\n编写语法规则文件（通常使用扩展名为 .y 的文件）,定义计算器的语法规则.以下是一个简单的例子:\n%{ #include %} %token NUMBER %left '+' '-' %left '*' '/' %precedence UMINUS %% expression: NUMBER | expression '+' expression | expression '-' expression | expression '*' expression | expression '/' expression | '-' expression %prec UMINUS ; %% int main() { yyparse(); return 0; } int yyerror(char const *msg) { fprintf(stderr, \"Error: %s\\n\", msg); return 0; } int yywrap() { return 1; } 其中,%{ 和 %} 之间的代码是在解析器中使用的C代码,%token 定义了词法分析器生成的符号类型,%left 和 %precedence 定义了运算符的优先级和结合性.%% 之间的是具体的语法规则,这里定义了 expression 表达式的语法规则,包括数字,加减乘除和取负操作.最后, main 函数调用 yyparse() 函数开始解析表达式, yyerror 和 yywrap 分别用于处理错误和结束解析器的工作.\n除了上述这个例子,手册中也给出了一个逆波兰表达式计算器的语法分析器示例,详见手册第2章.\n使用 bison 编译语法规则文件,生成解析器的源代码和头文件:\n$ bison -d calc.y 以上命令会生成 calc.tab.c 和 calc.tab.h 两个文件.\n编写词法分析器,可以手写或使用词法分析器生成器（如 flex ）. 编译词法分析器和解析器的源代码,生成可执行文件:\n$ gcc -o calc calc.tab.c lex.yy.c -lfl 其中, calc.tab.c 和 lex.yy.c 分别是 Bison 和 Flex 生成的解析器和词法分析器的源代码.\n运行可执行文件,并输入表达式进行计算:\n$ ./calc 使用 bison 描述 CFG 使用 bison 描述 CFG 有一些细节需要注意:\n使用小写字母来表示非终结符,比如 expr, stmt 等,当然这只是一种约定. 使用大写字母来表示终结符,比如 INTEGER, IF 等,当然这也是一种约定.另外, bison 中的终结符被称为 token kind .一个终结符代表了一门语言中的特定的关键字. error 由小写字母组成,但是是一个特殊的终结符. 也可以使用类似C语言中的字符常量来表示一个终结符,比如 'c' 表示字符 c 是一个终结符. 也可以使用类似C语言中的字符串常量来表示一个终结符,比如 \"string\" 表示字符串 string 是一个终结符. 一些形式化的概念 请参考龙书\n上下文无关语法 上下文无关语法（ CFG, Context Free Grammer ）的精确定义就不在这里给出了,可以参考龙书 4.2 节.\n既然有正则表达式,为什么又需要上下文无关语法？ 正则表达式和上下文无关语法都是用于描述语言的形式化工具,但是它们的能力是不同的.\n但是正则表达式只能描述正则语言,即只包含简单的模式匹配,字符类,重复等基本操作的语言.正则语言是一类较为简单的语言,可以用 DFA 或 NFA 进行识别和处理.\n相比之下, CFG 可以描述更加复杂的语言,包括可以用递归方式定义的语言. CFG 可以描述上下文无关语言,即不受上下文限制的语言,因此可以描述更加复杂的语言结构,如递归结构,嵌套结构,条件语句等.\n在编程语言等复杂语言的描述中,正则表达式通常不能描述所有语言特性.例如,在处理括号嵌套结构时,需要记录括号匹配的数量,这是一个上下文相关的问题,不能用正则表达式来描述.因此,需要使用CFG或者其他形式的文法来描述这种语言特性.\n语法分析算法 本节并没有详细说明每种算法的步骤,只是概括说明语法分析的大概方法,并且举了几个例子.\n自顶向下 自顶向下语法分析（Top-Down Parsing）是一种基于上下文无关文法的语法分析方法,它 从文法的起始符号开始 ,通过不断展开非终结符号,生成语法树,并最终判断输入是否符合文法规则.\n最常见的自顶向下语法分析算法是递归下降分析（Recursive Descent Parsing）,该算法通过递归调用自身,从起始符号开始,向下展开非终结符号,同时进行语法匹配.\n举个例子,我们有如下的文法:\n\u003cexpr\u003e ::= \u003cterm\u003e '+' \u003cterm\u003e \u003cterm\u003e ::= \u003cfactor\u003e '*' \u003cfactor\u003e | 'a' \u003cfactor\u003e ::= '(' \u003cexpr\u003e ')' | 'b' 其中,符号 , , 是非终结符号, + , * , ( , ) , a , b 是终结符号.起始符号是 .\n现在,我们要对字符串 a+b*(a+b) 进行自顶向下语法分析.具体步骤如下:\n从起始符号开始,展开为 '+' 从左侧的开始展开,展开为 '*' 从左侧的开始展开,展开为'a' 匹配输入字符串的第一个字符a,匹配成功 回到步骤2,从右侧的开始展开,展开为'(' ')' 匹配输入字符串的下一个字符+,匹配失败,回溯到步骤5 从左侧的开始展开,展开为 '+' 从左侧的开始展开,展开为 '*' 从左侧的开始展开,展开为'a' 匹配输入字符串的下一个字符+,匹配失败,回溯到步骤8 从右侧的开始展开,展开为'(' ')' 匹配输入字符串的下一个字符(,匹配成功 回到步骤1,从左侧的开始展开,展开为 '*' 从左侧的开始展开,展开为'b' 匹配输入字符串的下一个字符b,匹配成功 匹配输入字符串的下一个字符),匹配成功 匹配输入字符串的下一个字符*,匹配成功 回到步骤2,从右侧的开始展开,展开为'(' ')' 从左侧的开始展开,展开为 '+' 从左侧的开始展开,展开为 '*' 从左侧的开始展开,展开为'a' 匹配输入字符串的下一个字符+,匹配失败,回溯到步骤20 从右侧的开始展开,展开为'(' ')' 从左侧的开始展开,展开为 '+' 从左侧的开始展开,展开为 '*' 从左侧的开始展开,展开为'b' 匹配输入字符串的下一个字符b,匹配成功 匹配输入字符串的下一个字符),匹配成功 匹配输入字符串结束,语法匹配成功,生成语法树 可以看到,递归下降分析算法实际上就是对文法规则的一种直接翻译,算法简单直观,易于理解和实现.但是,它也存在一些缺点,如无法处理左递归的情况等问题,需要通过一些技巧进行处理.此外,对于一些复杂的文法规则,递归下降分析算法可能会因为回溯出现效率问题.\n左递归 自顶向下语法分析器不难实现,但是如果存在 左递归 的产生式,语法分析程序会陷入死递归.\n以下是一个左递归产生式的例子:\nE -\u003e E + T 其中, T 为终结符, E 为非终结符,如果递归的过程中不断进行最左推导,会导致递归无法返回.\n左递归包含了 直接左递归 和 间接左递归, 以下是一个 间接左递归 的例子:\nE -\u003e F + T F -\u003e E - T 如果要通过自顶向下的方法进行语法分析,就要先通过算法消除语法中的左递归.具体细节请参考教科书.\n自底向上 与自顶向下语法分析算法不同,自底向上语法分析算法从输入字符串的底部开始逐步向上构建语法分析树.\n常见的自底向上语法分析算法包括 LR（Left-to-right Rightmost）分析算法和 LALR（Lookahead LR）分析算法.这里以 LR(1) 分析算法为例进行说明.\n以文法规则为 E -\u003e E + T | E * T | T 为例,考虑对输入字符串 \"a + b * c\" 进行语法分析.下面是 LR(1) 分析算法的执行过程:\n初始化状态栈,将初始状态 0 压入栈中 读入输入字符串的第一个符号 a,查找状态 0 中是否有针对 a 的移进（shift）操作 由于状态 0 中不存在针对 a 的移进操作,查找状态 0 中是否有针对 E 的规约（reduce）操作,即 E -\u003e .E+T 由于状态 0 中存在 E -\u003e .E+T 的规约操作,执行规约操作,将栈顶的 3 个状态弹出,并将规约后的 E 符号压入状态栈中,得到状态 1 查找状态 1 中是否有针对 + 的移进操作 由于状态 1 中存在针对 + 的移进操作,执行移进操作,将状态 2 压入状态栈中,输入指针前移一位 读入输入字符串的下一个符号 b,查找状态 2 中是否有针对 b 的移进操作 由于状态 2 中存在针对 b 的移进操作,执行移进操作,将状态 3 压入状态栈中,输入指针前移一位 读入输入字符串的下一个符号 *,查找状态 3 中是否有针对 * 的移进操作 由于状态 3 中存在针对 * 的移进操作,执行移进操作,将状态 4 压入状态栈中,输入指针前移一位 读入输入字符串的下一个符号 c,查找状态 4 中是否有针对 c 的移进操作 由于状态 4 中存在针对 c 的移进操作,执行移进操作,将状态 5 压入状态栈中,输入指针前移一位 读入输入字符串的下一个符号 $,查找状态 5 中是否有针对 $ 的移进操作 由于状态 5 中不存在针对 $ 的移进操作,查找状态 5 中是否有针对 E 的规约操作,即 E -\u003e T,同时将输入指针后退一位 由于状态 5 中存在 E -\u003e T 的规约操作,执行规约操作,将栈顶的 2 个状态弹出,并将规约后的 E 符号压入状态栈中,得到状态 6 查找状态 6 中是否有针对 + 的移进操作 由于状态 6 中不存在针对 + 的移进操作,查找状态 6 中是否有针对 E 的规约操作,即 E -\u003e E+T 由于状态 6 中存在 E -\u003e E+T 的规约操作,执行规约操作,将栈顶的 3 个状态弹出,并将规约后的 E 符号压入状态栈中,得到状态 7 查找状态 7 中是否有针对 $ 的移进操作 由于状态 7 中存在针对 $ 的移进操作,执行移进操作,将状态 8 压入状态栈中,输入指针前移一位 读入输入字符串的下一个符号结束符,查找状态 8 中是否有针对结束符的移进操作 由于状态 8 中不存在针对结束符的移进操作,查找状态 8 中是否有针对 E 的规约操作,即 E -\u003e E+T,同时将输入指针后退一位 由于状态 8 中存在 E -\u003e E+T 的规约操作,执行规约操作,将栈顶的 3 个状态弹出,并将规约后的 E 符号压入状态栈中,得到状态 9 查找状态 9 中是否有针对 $ 的移进操作 由于状态 9 中不存在针对 $ 的移进操作,查找状态 9 中是否有针对 E 的规约操作,即 E -\u003e E+T,同时将输入指针后退一位 由于状态 9 中存在 E -\u003e T 的规约操作,执行规约操作,将栈顶的 2 个状态弹出,并将规约后的 E 符号压入状态栈中,得到状态 10 查找状态 10 中是否有针对 $ 的移进操作 由于状态 10 中存在针对 $ 的移进操作,执行移进操作,将状态 11 压入状态栈中,输入指针前移一位 读入输入字符串的下一个符号结束符,查找状态 11 中是否有针对结束符的移进操作 由于状态 11 中存在针对结束符的移进操作,分析结束 在以上过程中,状态栈的变化情况如下表所示:\n状态栈 输入指针 当前符号 动作 0 0 初始化 0 E 0 a 规约E-\u003e.E+T 0 E + 2 1 + 0 E + 2 T 2 b 移进,状态 3 0 E + 2 F 2 b 规约 F -\u003e .id 0 E + 2 E 2 b 规约 E -\u003e E+T 0 E + 5 2 b 查找状态 5,无操作 0 E + 5 * 3 c 移进,状态 4 0 E + 5 F 3 c 规约 F -\u003e .id 0 E + 5 T 3 c 规约 T -\u003e F 0 E + 5 E 3 c 规约 E -\u003e E+T 0 E + 6 3 c 查找状态 6,无操作 0 E + 6 * 4 d 移进,状态 4 0 E + 6 F 4 d 规约 F -\u003e .id 0 E + 6 T 4 d 规约 T -\u003e F*F 0 E + 6 E 4 d 规约 E -\u003e E+T 0 E + 6 $ 4 EOF 查找状态 8,无操作 0 E + 7 4 EOF 查找状态 7,无操作 0 E 4 EOF 规约 E -\u003e T 0 T 4 EOF 规约 T -\u003e F*F 0 T * F 4 EOF 规约 F -\u003e id 0 T * id 4 EOF 规约 F -\u003e id 0 T * 4 EOF 规约 T -\u003e F*F 0 T 4 EOF 规约 E -\u003e T 0 4 EOF 接受 从上表中可以看出,自底向上语法分析的过程中,状态栈和符号栈的元素随着分析过程的不断推进和弹出而不断变化.在分析到输入字符串的末尾时,如果状态栈中只有一个状态,且这个状态为文法的起始符号,那么说明分析成功.如果状态栈中不止一个状态,或者起始符号不在栈顶,那么说明分析失败,输入字符串不符合文法.\n自底向上语法分析的优点在于可以处理任意上下文无关文法,并且可以处理左递归的文法.而且,由于自底向上语法分析是从输入的最后一个符号开始分析,因此不需要像自顶向下语法分析那样需要将所有可能的推导路径都尝试一遍.这样,在一些复杂的文法中,自底向上语法分析的效率会更高一些.\n但是自底向上语法分析在运行过程中需要使用更多的内存来维护状态栈和符号栈,而且需要进行大量的状态转换,因此在一些简单的文法中,可能比自顶向下语法分析效率更低.此外,自底向上语法分析的输出也比较晦涩,很难直观地展示出语法分析树的结构.\nTODO 语法分析算法细节 自顶向下 or 自低向上？ 在选择自顶向下语法分析还是自底向上语法分析时,需要考虑到所处理的文法的复杂程度和所需的分析效率.\n对于简单的文法,自顶向下语法分析可能比较容易实现,并且分析速度比较快.自顶向下语法分析是从文法的起始符号开始推导,可以根据输入符号的类型和文法规则来选择合适的推导路径,因此比较灵活.\n而对于复杂的文法,特别是包含左递归和二义性的文法,自顶向下语法分析可能会出现回溯和死循环的情况,分析效率较低.此时,使用自底向上语法分析可能更为合适.自底向上语法分析是从输入符号开始,逐步合并符号并匹配到文法规则,因此可以处理任意上下文无关文法,并且能够处理左递归的文法.自底向上语法分析的效率可能比较低,但是对于复杂的文法,它是一种有效的分析方法.\n总而言之,在选择语法分析方法时,需要根据具体的文法和应用场景来进行选择,综合考虑分析效率,分析复杂度和分析输出的易读性等因素.\nbison 采用自底向上的分析算法 bison 内部使用的语法分析算法基于 LR 文法分析算法,其中的 L 表示从左到右扫描输入, R 表示使用最右派推导.\nbison 支持多种不同的 LR 文法分析算法,包括 SLR , LALR 和 LR1 等.在解析过程中, Bison 使用 LALR 分析器生成分析表,并使用状态机进行语法分析.\n","wordCount":"883","inLanguage":"en","datePublished":"2023-03-28T00:00:00Z","dateModified":"2023-03-28T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://tengwu.quest/2023/03/28/parser/"},"publisher":{"@type":"Organization","name":"me","logo":{"@type":"ImageObject","url":"http://tengwu.quest/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://tengwu.quest/ accesskey=h title="me (Alt + H)">me</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://tengwu.quest/categories/ title=categories><span>categories</span></a></li><li><a href=http://tengwu.quest/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://tengwu.quest/>Home</a>&nbsp;»&nbsp;<a href=http://tengwu.quest/2023/>2023s</a></div><h1 class=post-title>语法分析</h1><div class=post-meta><span title='2023-03-28 00:00:00 +0000 UTC'>March 28, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;883 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/tengwu/tengwu.github.io/blob/master/content/2023/03/28/parser.org rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=post-content><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>语法分析简介</h2><div id=outline-text-headline-1 class=outline-text-2><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>语法分析的任务</h3><div id=outline-text-headline-2 class=outline-text-3><p>语法分析是编译器继词法分析之后的一个重要步骤,主要任务是将输入的源代码转换为语法分析树或者抽象语法树,以便后续的语义分析,中间代码生成和优化等处理.</p><p>具体来说,语法分析的任务包括以下几个方面:</p><ol><li>识别输入的源代码中是否存在语法错误,即判断输入的源代码是否符合给定的文法规则.如果存在语法错误,语法分析器将报告相应的错误信息.</li><li>将输入的源代码转换为语法分析树或者抽象语法树.语法分析树是一个表示源代码语法结构的树形结构,每个节点代表源代码中的一个语法成分,如语句,表达式,运算符等.抽象语法树则是一种去除冗余信息后的语法树,只保留程序的语义信息,用于后续的代码生成和优化.</li><li>为每个节点附加语义信息,如数据类型,变量名,函数名等.这些信息将在后续的语义分析和代码生成中用到.</li><li>生成错误信息和警告信息,以便提示开发者对源代码进行改正.</li></ol></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>强大的语法分析生成器 <code class=verbatim>bison</code></h3><div id=outline-text-headline-3 class=outline-text-3><p><code class=verbatim>bison</code> 是 <code class=verbatim>flex</code> 的亲密战友,它是一种强大的语法分析器生成器,可以根据用户提供的上下文无关文法生成相应的语法分析器.</p><p><code class=verbatim>bison</code> 可以通过读取用户提供的语法规则,生成相应的语法分析器,从而将源代码转换为语法分析树或者抽象语法树,并对语法错误进行报告.</p><p>同时, <code class=verbatim>bison</code> 还提供了丰富的选项和功能,如语法冲突检查,语法错误处理,语法树的生成和遍历等,方便开发者进行灵活的配置和使用.</p><p><code class=verbatim>bison</code> 的语法规则基于类似于 <code class=verbatim>BNF</code> 的范式,可以包含终结符和非终结符,以及相应的语义动作.它使用 <code class=verbatim>LALR(1)</code> 分析算法,能够高效地处理大规模的语法规则和输入流,同时还提供了一些高级特性,如词法和语法错误处理,优先级和关联性规则,语法树生成和遍历等.</p><div id=outline-container-headline-4 class=outline-4><h4 id=headline-4>使用 <code class=verbatim>bison</code></h4><div id=outline-text-headline-4 class=outline-text-4><p><a href=https://www.gnu.org/software/bison/manual/html_node/Stages.html>手册1.8节</a>提供了使用 <code class=verbatim>bison</code> 的一般步骤.
使用 <code class=verbatim>bison</code> 生成语法分析器的基本步骤与使用 <code class=verbatim>flex</code> 非常类似,具体步骤如下:</p><ol><li>编写语法规则文件,将要分析的程序语言语法描述出来</li><li>使用 <code class=verbatim>bison</code> 编译语法规则文件,生成C文件</li><li>编译链接这些C文件成一个二进制程序</li><li>运行二进制程序,进行语法分析</li></ol><p>下面以分析计算器的语法为例,说明一下这四个步骤:</p><ol><li><p>编写语法规则文件（通常使用扩展名为 <code class=verbatim>.y</code> 的文件）,定义计算器的语法规则.以下是一个简单的例子:</p><div class="src src-c"><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=o>%</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=o>%</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>%</span><span class=n>token</span> <span class=n>NUMBER</span>
</span></span><span class=line><span class=cl>  <span class=o>%</span><span class=n>left</span> <span class=sc>&#39;+&#39;</span> <span class=sc>&#39;-&#39;</span>
</span></span><span class=line><span class=cl>  <span class=o>%</span><span class=n>left</span> <span class=sc>&#39;*&#39;</span> <span class=sc>&#39;/&#39;</span>
</span></span><span class=line><span class=cl>  <span class=o>%</span><span class=n>precedence</span> <span class=n>UMINUS</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>%%</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nl>expression</span><span class=p>:</span> <span class=n>NUMBER</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>expression</span> <span class=sc>&#39;+&#39;</span> <span class=n>expression</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>expression</span> <span class=sc>&#39;-&#39;</span> <span class=n>expression</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>expression</span> <span class=sc>&#39;*&#39;</span> <span class=n>expression</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>expression</span> <span class=sc>&#39;/&#39;</span> <span class=n>expression</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=sc>&#39;-&#39;</span> <span class=n>expression</span> <span class=o>%</span><span class=n>prec</span> <span class=n>UMINUS</span>
</span></span><span class=line><span class=cl>            <span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>%%</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>yyparse</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>yyerror</span><span class=p>(</span><span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>msg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>yywrap</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span></span></span></code></pre></div></div><p>其中,%{ 和 %} 之间的代码是在解析器中使用的C代码,%token 定义了词法分析器生成的符号类型,%left 和 %precedence 定义了运算符的优先级和结合性.%% 之间的是具体的语法规则,这里定义了 expression 表达式的语法规则,包括数字,加减乘除和取负操作.最后, main 函数调用 yyparse() 函数开始解析表达式, yyerror 和 yywrap 分别用于处理错误和结束解析器的工作.</p><p>除了上述这个例子,手册中也给出了一个逆波兰表达式计算器的语法分析器示例,详见<a href=https://www.gnu.org/software/bison/manual/html_node/Examples.html>手册第2章</a>.</p></li><li><p>使用 <code class=verbatim>bison</code> 编译语法规则文件,生成解析器的源代码和头文件:</p><div class="src src-sh"><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>  $ bison -d calc.y</span></span></code></pre></div></div><p>以上命令会生成 calc.tab.c 和 calc.tab.h 两个文件.</p></li><li>编写词法分析器,可以手写或使用词法分析器生成器（如 <code class=verbatim>flex</code> ）.</li><li><p>编译词法分析器和解析器的源代码,生成可执行文件:</p><div class="src src-sh"><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>  $ gcc -o calc calc.tab.c lex.yy.c -lfl</span></span></code></pre></div></div><p>其中, calc.tab.c 和 lex.yy.c 分别是 Bison 和 Flex 生成的解析器和词法分析器的源代码.</p></li><li><p>运行可执行文件,并输入表达式进行计算:</p><div class="src src-sh"><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>  $ ./calc</span></span></code></pre></div></div></li></ol></div></div><div id=outline-container-headline-5 class=outline-4><h4 id=headline-5>使用 <code class=verbatim>bison</code> 描述 <code class=verbatim>CFG</code></h4><div id=outline-text-headline-5 class=outline-text-4><p>使用 <code class=verbatim>bison</code> 描述 <code class=verbatim>CFG</code> 有一些细节需要注意:</p><ol><li>使用小写字母来表示非终结符,比如 <code class=verbatim>expr</code>, <code class=verbatim>stmt</code> 等,当然这只是一种约定.</li><li>使用大写字母来表示终结符,比如 <code class=verbatim>INTEGER</code>, <code class=verbatim>IF</code> 等,当然这也是一种约定.另外, <code class=verbatim>bison</code> 中的终结符被称为 <code class=verbatim>token kind</code> .一个终结符代表了一门语言中的特定的关键字.
<code class=verbatim>error</code> 由小写字母组成,但是是一个特殊的终结符.</li><li>也可以使用类似C语言中的字符常量来表示一个终结符,比如 <code class=verbatim>'c'</code> 表示字符 <code class=verbatim>c</code> 是一个终结符.</li><li>也可以使用类似C语言中的字符串常量来表示一个终结符,比如 <code class=verbatim>"string"</code> 表示字符串 <code class=verbatim>string</code> 是一个终结符.</li></ol></div></div></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6><del>一些形式化的概念</del></h3><div id=outline-text-headline-6 class=outline-text-3><p><del>请参考龙书</del></p></div></div></div></div><div id=outline-container-headline-7 class=outline-2><h2 id=headline-7>上下文无关语法</h2><div id=outline-text-headline-7 class=outline-text-2><p>上下文无关语法（ <code class=verbatim>CFG, Context Free Grammer</code> ）的精确定义就不在这里给出了,可以参考龙书 <code class=verbatim>4.2</code> 节.</p><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>既然有正则表达式,为什么又需要上下文无关语法？</h3><div id=outline-text-headline-8 class=outline-text-3><p>正则表达式和上下文无关语法都是用于描述语言的形式化工具,但是它们的能力是不同的.</p><p>但是正则表达式只能描述正则语言,即只包含简单的模式匹配,字符类,重复等基本操作的语言.正则语言是一类较为简单的语言,可以用 <code class=verbatim>DFA</code> 或 <code class=verbatim>NFA</code> 进行识别和处理.</p><p>相比之下, <code class=verbatim>CFG</code> 可以描述更加复杂的语言,包括可以用递归方式定义的语言. <code class=verbatim>CFG</code> 可以描述上下文无关语言,即不受上下文限制的语言,因此可以描述更加复杂的语言结构,如递归结构,嵌套结构,条件语句等.</p><p>在编程语言等复杂语言的描述中,正则表达式通常不能描述所有语言特性.例如,在处理括号嵌套结构时,需要记录括号匹配的数量,这是一个上下文相关的问题,不能用正则表达式来描述.因此,需要使用CFG或者其他形式的文法来描述这种语言特性.</p></div></div></div></div><div id=outline-container-headline-9 class=outline-2><h2 id=headline-9>语法分析算法</h2><div id=outline-text-headline-9 class=outline-text-2><p>本节并没有详细说明每种算法的步骤,只是概括说明语法分析的大概方法,并且举了几个例子.</p><div id=outline-container-headline-10 class=outline-3><h3 id=headline-10>自顶向下</h3><div id=outline-text-headline-10 class=outline-text-3><p>自顶向下语法分析（Top-Down Parsing）是一种基于上下文无关文法的语法分析方法,它 <strong>从文法的起始符号开始</strong> ,通过不断展开非终结符号,生成语法树,并最终判断输入是否符合文法规则.</p><p>最常见的自顶向下语法分析算法是递归下降分析（Recursive Descent Parsing）,该算法通过递归调用自身,从起始符号开始,向下展开非终结符号,同时进行语法匹配.</p><p>举个例子,我们有如下的文法:</p><div class="src src-scss"><div class=highlight><pre tabindex=0 class=chroma><code class=language-scss data-lang=scss><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nt>expr</span><span class=o>&gt;</span> <span class=nd>::</span><span class=o>=</span> <span class=o>&lt;</span><span class=nt>term</span><span class=o>&gt;</span> <span class=s1>&#39;+&#39;</span> <span class=o>&lt;</span><span class=nt>term</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nt>term</span><span class=o>&gt;</span> <span class=nd>::</span><span class=o>=</span> <span class=o>&lt;</span><span class=nt>factor</span><span class=o>&gt;</span> <span class=s1>&#39;*&#39;</span> <span class=o>&lt;</span><span class=nt>factor</span><span class=o>&gt;</span> <span class=o>|</span> <span class=s1>&#39;a&#39;</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nt>factor</span><span class=o>&gt;</span> <span class=nd>::</span><span class=o>=</span> <span class=s1>&#39;(&#39;</span> <span class=o>&lt;</span><span class=nt>expr</span><span class=o>&gt;</span> <span class=s1>&#39;)&#39;</span> <span class=o>|</span> <span class=s1>&#39;b&#39;</span></span></span></code></pre></div></div><p>其中,符号 <code class=verbatim>&lt;expr></code> , <code class=verbatim>&lt;term></code> , <code class=verbatim>&lt;factor></code> 是非终结符号, <code class=verbatim>+</code> , <code class=verbatim>*</code> , <code class=verbatim>(</code> , <code class=verbatim>)</code> , <code class=verbatim>a</code> , <code class=verbatim>b</code> 是终结符号.起始符号是 <code class=verbatim>&lt;expr></code> .</p><p>现在,我们要对字符串 <code class=verbatim>a+b*(a+b)</code> 进行自顶向下语法分析.具体步骤如下:</p><ol><li>从起始符号&lt;expr>开始,展开为&lt;term> '+' &lt;term></li><li>从左侧的&lt;term>开始展开,展开为&lt;factor> '*' &lt;factor></li><li>从左侧的&lt;factor>开始展开,展开为'a'</li><li>匹配输入字符串的第一个字符a,匹配成功</li><li>回到步骤2,从右侧的&lt;factor>开始展开,展开为'(' &lt;expr> ')'</li><li>匹配输入字符串的下一个字符+,匹配失败,回溯到步骤5</li><li>从左侧的&lt;expr>开始展开,展开为&lt;term> '+' &lt;term></li><li>从左侧的&lt;term>开始展开,展开为&lt;factor> '*' &lt;factor></li><li>从左侧的&lt;factor>开始展开,展开为'a'</li><li>匹配输入字符串的下一个字符+,匹配失败,回溯到步骤8</li><li>从右侧的&lt;factor>开始展开,展开为'(' &lt;expr> ')'</li><li>匹配输入字符串的下一个字符(,匹配成功</li><li>回到步骤1,从左侧的&lt;term>开始展开,展开为&lt;factor> '*' &lt;factor></li><li>从左侧的&lt;factor>开始展开,展开为'b'</li><li>匹配输入字符串的下一个字符b,匹配成功</li><li>匹配输入字符串的下一个字符),匹配成功</li><li>匹配输入字符串的下一个字符*,匹配成功</li><li>回到步骤2,从右侧的&lt;factor>开始展开,展开为'(' &lt;expr> ')'</li><li>从左侧的&lt;expr>开始展开,展开为&lt;term> '+' &lt;term></li><li>从左侧的&lt;term>开始展开,展开为&lt;factor> '*' &lt;factor></li><li>从左侧的&lt;factor>开始展开,展开为'a'</li><li>匹配输入字符串的下一个字符+,匹配失败,回溯到步骤20</li><li>从右侧的&lt;factor>开始展开,展开为'(' &lt;expr> ')'</li><li>从左侧的&lt;expr>开始展开,展开为&lt;term> '+' &lt;term></li><li>从左侧的&lt;term>开始展开,展开为&lt;factor> '*' &lt;factor></li><li>从左侧的&lt;factor>开始展开,展开为'b'</li><li>匹配输入字符串的下一个字符b,匹配成功</li><li>匹配输入字符串的下一个字符),匹配成功</li><li>匹配输入字符串结束,语法匹配成功,生成语法树</li></ol><p>可以看到,递归下降分析算法实际上就是对文法规则的一种直接翻译,算法简单直观,易于理解和实现.但是,它也存在一些缺点,如无法处理左递归的情况等问题,需要通过一些技巧进行处理.此外,对于一些复杂的文法规则,递归下降分析算法可能会因为回溯出现效率问题.</p><div id=outline-container-headline-11 class=outline-4><h4 id=headline-11>左递归</h4><div id=outline-text-headline-11 class=outline-text-4><p>自顶向下语法分析器不难实现,但是如果存在 <code class=verbatim>左递归</code> 的产生式,语法分析程序会陷入死递归.</p><p>以下是一个左递归产生式的例子:</p><div class="src src-scss"><div class=highlight><pre tabindex=0 class=chroma><code class=language-scss data-lang=scss><span class=line><span class=cl>  <span class=nt>E</span> <span class=o>-&gt;</span> <span class=nt>E</span> <span class=o>+</span> <span class=nt>T</span></span></span></code></pre></div></div><p>其中, <code class=verbatim>T</code> 为终结符, <code class=verbatim>E</code> 为非终结符,如果递归的过程中不断进行最左推导,会导致递归无法返回.</p><p>左递归包含了 <code class=verbatim>直接左递归</code> 和 <code class=verbatim>间接左递归</code>, 以下是一个 <code class=verbatim>间接左递归</code> 的例子:</p><div class="src src-scss"><div class=highlight><pre tabindex=0 class=chroma><code class=language-scss data-lang=scss><span class=line><span class=cl>  <span class=nt>E</span> <span class=o>-&gt;</span> <span class=nt>F</span> <span class=o>+</span> <span class=nt>T</span>
</span></span><span class=line><span class=cl>  <span class=nt>F</span> <span class=o>-&gt;</span> <span class=nt>E</span> <span class=o>-</span> <span class=nt>T</span></span></span></code></pre></div></div><p>如果要通过自顶向下的方法进行语法分析,就要先通过算法消除语法中的左递归.具体细节请参考教科书.</p></div></div></div></div><div id=outline-container-headline-12 class=outline-3><h3 id=headline-12>自底向上</h3><div id=outline-text-headline-12 class=outline-text-3><p>与自顶向下语法分析算法不同,自底向上语法分析算法从输入字符串的底部开始逐步向上构建语法分析树.</p><p>常见的自底向上语法分析算法包括 LR（Left-to-right Rightmost）分析算法和 LALR（Lookahead LR）分析算法.这里以 LR(1) 分析算法为例进行说明.</p><p>以文法规则为 <code class=verbatim>E -> E + T | E * T | T</code> 为例,考虑对输入字符串 "a + b * c" 进行语法分析.下面是 LR(1) 分析算法的执行过程:</p><ol><li>初始化状态栈,将初始状态 0 压入栈中</li><li>读入输入字符串的第一个符号 a,查找状态 0 中是否有针对 a 的移进（shift）操作</li><li>由于状态 0 中不存在针对 a 的移进操作,查找状态 0 中是否有针对 E 的规约（reduce）操作,即 E -> .E+T</li><li>由于状态 0 中存在 E -> .E+T 的规约操作,执行规约操作,将栈顶的 3 个状态弹出,并将规约后的 E 符号压入状态栈中,得到状态 1</li><li>查找状态 1 中是否有针对 + 的移进操作</li><li>由于状态 1 中存在针对 + 的移进操作,执行移进操作,将状态 2 压入状态栈中,输入指针前移一位</li><li>读入输入字符串的下一个符号 b,查找状态 2 中是否有针对 b 的移进操作</li><li>由于状态 2 中存在针对 b 的移进操作,执行移进操作,将状态 3 压入状态栈中,输入指针前移一位</li><li>读入输入字符串的下一个符号 *,查找状态 3 中是否有针对 * 的移进操作</li><li>由于状态 3 中存在针对 * 的移进操作,执行移进操作,将状态 4 压入状态栈中,输入指针前移一位</li><li>读入输入字符串的下一个符号 c,查找状态 4 中是否有针对 c 的移进操作</li><li>由于状态 4 中存在针对 c 的移进操作,执行移进操作,将状态 5 压入状态栈中,输入指针前移一位</li><li>读入输入字符串的下一个符号 $,查找状态 5 中是否有针对 $ 的移进操作</li><li>由于状态 5 中不存在针对 $ 的移进操作,查找状态 5 中是否有针对 E 的规约操作,即 E -> T,同时将输入指针后退一位</li><li>由于状态 5 中存在 E -> T 的规约操作,执行规约操作,将栈顶的 2 个状态弹出,并将规约后的 E 符号压入状态栈中,得到状态 6</li><li>查找状态 6 中是否有针对 + 的移进操作</li><li>由于状态 6 中不存在针对 + 的移进操作,查找状态 6 中是否有针对 E 的规约操作,即 E -> E+T</li><li>由于状态 6 中存在 E -> E+T 的规约操作,执行规约操作,将栈顶的 3 个状态弹出,并将规约后的 E 符号压入状态栈中,得到状态 7</li><li>查找状态 7 中是否有针对 $ 的移进操作</li><li>由于状态 7 中存在针对 $ 的移进操作,执行移进操作,将状态 8 压入状态栈中,输入指针前移一位</li><li>读入输入字符串的下一个符号结束符,查找状态 8 中是否有针对结束符的移进操作</li><li>由于状态 8 中不存在针对结束符的移进操作,查找状态 8 中是否有针对 E 的规约操作,即 E -> E+T,同时将输入指针后退一位</li><li>由于状态 8 中存在 E -> E+T 的规约操作,执行规约操作,将栈顶的 3 个状态弹出,并将规约后的 E 符号压入状态栈中,得到状态 9</li><li>查找状态 9 中是否有针对 $ 的移进操作</li><li>由于状态 9 中不存在针对 $ 的移进操作,查找状态 9 中是否有针对 E 的规约操作,即 E -> E+T,同时将输入指针后退一位</li><li>由于状态 9 中存在 E -> T 的规约操作,执行规约操作,将栈顶的 2 个状态弹出,并将规约后的 E 符号压入状态栈中,得到状态 10</li><li>查找状态 10 中是否有针对 $ 的移进操作</li><li>由于状态 10 中存在针对 $ 的移进操作,执行移进操作,将状态 11 压入状态栈中,输入指针前移一位</li><li>读入输入字符串的下一个符号结束符,查找状态 11 中是否有针对结束符的移进操作</li><li>由于状态 11 中存在针对结束符的移进操作,分析结束</li></ol><p>在以上过程中,状态栈的变化情况如下表所示:</p><table><tbody><tr><td>状态栈</td><td class=align-right>输入指针</td><td>当前符号</td><td>动作</td></tr><tr><td>0</td><td class=align-right>0</td><td></td><td>初始化</td></tr><tr><td>0 E</td><td class=align-right>0</td><td>a</td><td>规约E->.E+T</td></tr><tr><td>0 E + 2</td><td class=align-right>1</td><td>+</td><td></td></tr><tr><td>0 E + 2 T</td><td class=align-right>2</td><td>b</td><td>移进,状态 3</td></tr><tr><td>0 E + 2 F</td><td class=align-right>2</td><td>b</td><td>规约 F -> .id</td></tr><tr><td>0 E + 2 E</td><td class=align-right>2</td><td>b</td><td>规约 E -> E+T</td></tr><tr><td>0 E + 5</td><td class=align-right>2</td><td>b</td><td>查找状态 5,无操作</td></tr><tr><td>0 E + 5 *</td><td class=align-right>3</td><td>c</td><td>移进,状态 4</td></tr><tr><td>0 E + 5 F</td><td class=align-right>3</td><td>c</td><td>规约 F -> .id</td></tr><tr><td>0 E + 5 T</td><td class=align-right>3</td><td>c</td><td>规约 T -> F</td></tr><tr><td>0 E + 5 E</td><td class=align-right>3</td><td>c</td><td>规约 E -> E+T</td></tr><tr><td>0 E + 6</td><td class=align-right>3</td><td>c</td><td>查找状态 6,无操作</td></tr><tr><td>0 E + 6 *</td><td class=align-right>4</td><td>d</td><td>移进,状态 4</td></tr><tr><td>0 E + 6 F</td><td class=align-right>4</td><td>d</td><td>规约 F -> .id</td></tr><tr><td>0 E + 6 T</td><td class=align-right>4</td><td>d</td><td>规约 T -> F*F</td></tr><tr><td>0 E + 6 E</td><td class=align-right>4</td><td>d</td><td>规约 E -> E+T</td></tr><tr><td>0 E + 6 $</td><td class=align-right>4</td><td>EOF</td><td>查找状态 8,无操作</td></tr><tr><td>0 E + 7</td><td class=align-right>4</td><td>EOF</td><td>查找状态 7,无操作</td></tr><tr><td>0 E</td><td class=align-right>4</td><td>EOF</td><td>规约 E -> T</td></tr><tr><td>0 T</td><td class=align-right>4</td><td>EOF</td><td>规约 T -> F*F</td></tr><tr><td>0 T * F</td><td class=align-right>4</td><td>EOF</td><td>规约 F -> id</td></tr><tr><td>0 T * id</td><td class=align-right>4</td><td>EOF</td><td>规约 F -> id</td></tr><tr><td>0 T *</td><td class=align-right>4</td><td>EOF</td><td>规约 T -> F*F</td></tr><tr><td>0 T</td><td class=align-right>4</td><td>EOF</td><td>规约 E -> T</td></tr><tr><td>0</td><td class=align-right>4</td><td>EOF</td><td>接受</td></tr></tbody></table><p>从上表中可以看出,自底向上语法分析的过程中,状态栈和符号栈的元素随着分析过程的不断推进和弹出而不断变化.在分析到输入字符串的末尾时,如果状态栈中只有一个状态,且这个状态为文法的起始符号,那么说明分析成功.如果状态栈中不止一个状态,或者起始符号不在栈顶,那么说明分析失败,输入字符串不符合文法.</p><p>自底向上语法分析的优点在于可以处理任意上下文无关文法,并且可以处理左递归的文法.而且,由于自底向上语法分析是从输入的最后一个符号开始分析,因此不需要像自顶向下语法分析那样需要将所有可能的推导路径都尝试一遍.这样,在一些复杂的文法中,自底向上语法分析的效率会更高一些.</p><p>但是自底向上语法分析在运行过程中需要使用更多的内存来维护状态栈和符号栈,而且需要进行大量的状态转换,因此在一些简单的文法中,可能比自顶向下语法分析效率更低.此外,自底向上语法分析的输出也比较晦涩,很难直观地展示出语法分析树的结构.</p><div id=outline-container-headline-13 class=outline-4><h4 id=headline-13><span class=todo>TODO</span>
语法分析算法细节</h4></div></div></div><div id=outline-container-headline-14 class=outline-3><h3 id=headline-14>自顶向下 or 自低向上？</h3><div id=outline-text-headline-14 class=outline-text-3><p>在选择自顶向下语法分析还是自底向上语法分析时,需要考虑到所处理的文法的复杂程度和所需的分析效率.</p><p>对于简单的文法,自顶向下语法分析可能比较容易实现,并且分析速度比较快.自顶向下语法分析是从文法的起始符号开始推导,可以根据输入符号的类型和文法规则来选择合适的推导路径,因此比较灵活.</p><p>而对于复杂的文法,特别是包含左递归和二义性的文法,自顶向下语法分析可能会出现回溯和死循环的情况,分析效率较低.此时,使用自底向上语法分析可能更为合适.自底向上语法分析是从输入符号开始,逐步合并符号并匹配到文法规则,因此可以处理任意上下文无关文法,并且能够处理左递归的文法.自底向上语法分析的效率可能比较低,但是对于复杂的文法,它是一种有效的分析方法.</p><p>总而言之,在选择语法分析方法时,需要根据具体的文法和应用场景来进行选择,综合考虑分析效率,分析复杂度和分析输出的易读性等因素.</p></div></div><div id=outline-container-headline-15 class=outline-3><h3 id=headline-15><code class=verbatim>bison</code> 采用自底向上的分析算法</h3><div id=outline-text-headline-15 class=outline-text-3><p><code class=verbatim>bison</code> 内部使用的语法分析算法基于 <code class=verbatim>LR</code> 文法分析算法,其中的 <code class=verbatim>L</code> 表示从左到右扫描输入, <code class=verbatim>R</code> 表示使用最右派推导.</p><p><code class=verbatim>bison</code> 支持多种不同的 <code class=verbatim>LR</code> 文法分析算法,包括 <code class=verbatim>SLR</code> , <code class=verbatim>LALR</code> 和 <code class=verbatim>LR1</code> 等.在解析过程中, <code class=verbatim>Bison</code> 使用 <code class=verbatim>LALR</code> 分析器生成分析表,并使用状态机进行语法分析.</p></div></div></div></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://tengwu.quest/2023/03/28/lexer/><span class=title>« Prev</span><br><span>词法分析</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://tengwu.quest/>me</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>